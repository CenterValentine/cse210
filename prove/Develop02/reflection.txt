
The definition given in the course material of turning complex ideas into simple ideas initially made the process of abstraction sound easy, simple maybe even a little fun. With the application of this lesson I learned that abstraction in terms of coding involves understanding the task at hand and how that task might be expressed in code.  I was quite surprised at the simplicity and comprehensiveness of classes (this being a benefit).  Being able to depend on such a simple process of referring to parent and child classes felt a bit awkward and unusual at first but perhaps it was because it made coding easier because I didn't have to repeat myself.

In the real world, objects, things, or ideas can have a lot more too them than meets the eye.  A dog, for example, has fur, cells, organs, bad breath, and they bark or howl.   Programming a dog requires an abstraction of reality into code expression(s) that encapsulate the idea of a dog or whatever goal the programmer is after.  

In the assignment I was rather surprised to discover classes and that we had a unique class for each single entry.  Discovering this stretched my mind a bit but I have since come to terms with it and I've embraced how such a class allows the application to be managed and scaled efficiently.   Using the Journal class to call the entry class and have the journal keep a list (of that class as a data type) was surprisingly simple, but it took me some time to realize how simple it could be!  Displaying/printing all the journal entires was done by referring to that classes display/print function by looping through that array of entries in the journal class.  Thinking abstractly overall requires separating things that you wouldn't otherwise consider separating.  However this sort of separation actually makes scaling, or building and maintaining an application practical by reducing repetition and allowing contributions to be made with much less complication.  
